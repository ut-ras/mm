Pseudocode for Various Maze Solving Algorithms
Context and Assumptions:
  ~ The mouse will be placed in a corner, with its back faced against the wall,
    and its left and right sides are blocked by walls. The goal is in the center.
  ~ https://github.com/theJollySin/mazelib/blob/master/docs/MAZE_SOLVE_ALGOS.md
  ~ http://www.astrolog.org/labyrnth/algrithm.htm

Wall Follower
  ~ Choose left or right side to follow.
  ~ Go forward until a junction is met
  ~ Choose the rightmost path (defined as the right of the centerline determined
    by the average angle of all possible directions - i.e. left, center:
    centerline is center left, go center)
  ~ Continue until the next junction. If a dead end is reached, turn around and
    follow the wall and turn right respective of the orientation of the mouse.
Right Hand Rule
  ~ Same as wall follower, but smarter. If the mouse returns to a junction from
    a dead end, remember original orientation and go down the second most right path.
  NOTE:
  ~ This and the previous algorithm are very inefficient.

Tremaux's Algorithm/Recursive Backtracker (I have C code with this implementation)
  ~ Hold internal directions in memory
  ~ At each cell, check if junction or corridor (3/4 directions without walls vs only 2)
    ~ If corridor - move in the direction with the least marks
    ~ If junction - move in the direction with the least marks, do not move in a
      direction that holds a wall.
  ~ Mark each cell previously on either once or twice. Consider twice marked paths
    walls. This means you cannot backtrack on dead ends.
  ~ Priority of direction is based on the affiliated cell in that direction.
    cells closer to the endpoint (the center) means their direction is prioritized.
    ~ Maybe use Pythagorean theorem. Or base distance on the distance across x + y axis.
  NOTE:
  ~ This is slow, probably best for mapping out a maze without knowing the interior layout.
  ~ Requires a grid memory layout (robot is in [x,y] box), which isn't very accurate.

NOTE: The following algorithms require the maze already be explored to the end point.
  They will be useful for finding the fastest known solution in the known maze.
Dead End Filler (I also have C code with this implementation)
  ~ Given a known maze, assuming all unexplored parts are unknown, and thus dead ends
    fill up the ends of the dead ends until they reach a junction.
  ~ Also known in dungeon generation as sparseness. (http://journal.stuffwithstuff.com/2014/12/21/rooms-and-mazes/)
Cul-de-sac Filler
  ~ Dead end filler but removes loops that are also dead ends.
  ~ Looks for noose junctions (loops that do not lead to a solution, and have
    only one extending corridor) and closes them (adds a wall there).
  ~ Rinse and repeat until no change.
  ~ Does not work well for complicated heavily braid mazes
Flood Fill/Shortest Paths Finder/Breadth First Search
  ~ Floods the maze from the start with "water", and each grid square is marked
    when the water reaches it. It spreads in all directions in a junction equally.
  ~ When the solution spot is reached by the water, trace backwards and that's
    a shortest path.
  ~ This can be repeated and the top n solutions are selected (possibly x lengths
    from the shortest path. This reduces the chance of being stuck in a loop, etc.)
  ~ Optimize based on the mouse specifications.
  ~ This can be simplified by using a preprocessing filter: using Dead End Filler
    or Cul-de-sac filler to remove extraneous loops and dead ends.

Suggestion of procedure:
  ~ Use Tremaux's algorithm/Recursive Backtracker to scope out the unknown maze to the solution.
  ~ Similarly, use Tremaux's algorithm to go back to the start, but in an opposite direction
    of the solution path, to more fully explore the maze.
  ~ Then given the complete/less incomplete map of the maze, apply Cul-de-sac Filler
    and Dead End Filler until further iterations do not change the maze.
  ~ Use Flood Fill/BFS/Shortest Paths Finder to determine the top N paths that are
    x unit distances from the shortest path.
  ~ Run the mouse on the path most optimized for it.
  ~ Possibly based on user input, have 3 LEDs on the mouse that indicate which
    path it will run; have a user change settings to switch between paths, in addition
    to a speed setting, explore/run setting.
